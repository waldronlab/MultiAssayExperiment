---
title: "biocMultiAssayToyExample"
author: "Marcel Ramos, Levi Waldron"
date: "October 3, 2015"
output: 
  html_document: 
    number_sections: yes
    toc: yes
---

# Generate toy data

In this example we have 4 patients, and a bit of metadata on them:
```{r}
masPheno <- data.frame(sex=c("M", "F", "M", "F"),
						  age=38:41,
						  row.names=c("Jack", "Jill", "Bob", "Barbara"))
masPheno
```

We have three matrix-like datasets.  First let's say expression data:

```{r, message=FALSE}
library(affy)
(arraydat <- matrix(seq(101, 108), ncol=4, dimnames=list(c("ENST00000294241", "ENST00000355076"), c("array1", "array2", "array3", "array4"))))
arraypdat <- as(data.frame(slope53=rnorm(4), row.names=c("array1", "array2", "array3", "array4")), "AnnotatedDataFrame")
exprdat <- ExpressionSet(assayData=arraydat, phenoData=arraypdat)
exprdat
```

The following map matches masterPheno sample names to exprdata sample names.  Note that row orders aren't initially matched up.
```{r}
(exprmap <- data.frame(master=rownames(masPheno)[c(1, 2, 4, 3)], assay=c("array1", "array2", "array3", "array4")))
```

Now methylation data.  It uses gene identifiers also, but measures a partially overlapping set of genes.  For fun, let's store this as a simple matrix. Also, it contains a replicate for one of the patients.

```{r}
(methyldat <- matrix(1:10, ncol=5, 
                     dimnames=list(c("ENST00000355076", "ENST00000383706"),
                                   c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5"))))
```

The following map matches masterPheno sample names to methyldat sample names.

```{r}
(methylmap <- data.frame(master = c("Jack", "Jack", "Jill", "Barbara", "Bob"),
                        assay = c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5")))
```

Now we have a microRNA platform, which has no common identifiers.  It is also missing data for Jill.  Just for fun, let's use the same sample naming convention as we did for arrays.

```{r}
(microdat <- matrix(201:212, ncol=3, 
                    dimnames=list(c("hsa-miR-21", "hsa-miR-191", "hsa-miR-148a", "hsa-miR148b"), 
                                  c("array1", "array2", "array3"))))
```

And the following map matches masterPheno sample names to microdat sample names.
```{r}
(micromap <- data.frame(master = c("Jack", "Barbara", "Bob"),
                        assay = c("micro1", "micro2", "micro3")))
```

Let's include a GRangesList:  

```{r}
library(GenomicRanges)
gr1 <-
  GRanges(seqnames = "chr3", ranges = IRanges(58000000, 59502360), #completely encompasses ENST00000355076
          strand = "+", score = 5L, GC = 0.45)
gr2 <-
  GRanges(seqnames = c("chr3", "chr3"),
          ranges = IRanges(c(58493000, 3), width=9000), #first is within ENST0000035076
          strand = c("+", "-"), score = 3:4, GC = c(0.3, 0.5))
gr3 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(1, 4), c(3, 9)),
          strand = c("-", "-"), score = c(6L, 2L), GC = c(0.4, 0.1))
grl <- GRangesList("gr1" = gr1, "gr2" = gr2, "gr3" = gr3)
names(grl) <- c("snparray1", "snparray2", "snparray3")
grl
```

The following data.frame matches masterPheno sample to the GRangesList: 

```{r}
(rangemap <- data.frame(master = c("Jack", "Jill", "Jill"), 
						assay = c("snparray1", "snparray2", "snparray3")))
```

#Setup for creating MultiAssayExperiment
Create an ID map for all available experiments.  Names required, and must be identical to names of elist (TODO: add to validity check).

```{r}
idmap <- list(exprmap, methylmap, micromap, rangemap)
names(idmap) <- c("Affy", "Methyl 450k", "Mirna", "CNV gistic")
idmap
```

Allowing for the possibility of ID maps entered as dataframes, convert to conventional list: 

```{r}
library(reshape2) # reshape2 used for example only
dfmap <- melt(idmap, id.var = c("master", "assay"))
library(biocMultiAssay)
toListMap(dfmap)
```

Create an named list of experiments `objlist` for the MultiAssay function

```{r}
objlist <- list("Affy" = exprdat, "Methyl 450k" = methyldat, "Mirna" = microdat, "CNV gistic" = grl)
```

# Create a multiAssayExperiment class object

```{r}
myMultiAssay <- MultiAssay(objlist, masPheno, idmap)
myMultiAssay
```

# Subsetting by Sample

```{r}
logicID <- identifyBySample(myMultiAssay, 1:2)
logicID
subMultiAssay <- subsetBySample(myMultiAssay, logicID)
subMultiAssay
```

# TODO - subset myMultiAssay by assays

Endogenous operation, returns a MultiAssay object containing elist of length 1, map of length 1, and masterPheno for only Jack, Barbara, and Bob.  The "Mirna" argument is used to index the elist object using `[`, so could also be integer or logical:
```{r, eval=FALSE}
subsetByAssay(myMultiAssay, "Mirna", drop=FALSE)
```

Not endogenous, returns just the matrix contained in elist$micro:
```{r, eval=FALSE}
subsetByAssay(myMultiAssay, "Mirna", drop=TRUE)
```

# TODO - subset myMultiAssay by matrix-like features

This operation should always return a MultiAssayExperiment class, with any elist element not containing the feature having zero rows.

Until we make subsetting by a gene ID work on ranges, the following will return c(TRUE, TRUE, FALSE, FALSE). When we implement subsetting by ranges, it should return c(TRUE, TRUE, FALSE, TRUE). 

Returns c(TRUE, TRUE, FALSE, FALSE):
```{r, eval=FALSE}
identifyByFeature(myMultiAssay, "ENST0000035076")  
```

Returns MultiAssayExperiment where `Affy` and `Methyl 450k` contain only ENST0000035076 row, and "Mirna" and "CNV gistic" have zero rows:
```{r, eval=FALSE}
subsetByFeature(myMultiAssay, "ENST0000035076")  
```

In the following, `Affy` ExpressionSet keeps both rows but with their order reversed, and `Methyl 450k` keeps only its second row.
```{r, eval=FALSE}
subsetByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"))
```

## Identify assays that contain any / all of a vector of features

Note that the output of this function could be used as the input for subsetByAssay.
```{r, eval=FALSE}
identifyByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"), requireall=FALSE)  #returns c(TRUE, TRUE, FALSE, FALSE)
identifyByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"), requireall=TRUE)  #returns c(TRUE, FALSE, FALSE, FALSE)
```

# TODO later - subset by ranges
Use GenomicRanges::subsetByOverlaps, passing its arguments to allow flexible types of subsetting. 